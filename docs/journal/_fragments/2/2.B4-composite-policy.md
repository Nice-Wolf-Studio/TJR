# [P2][B4] Composite Selection Policy

**Date:** 2025-09-30
**Phase:** 2
**Shard:** B4
**Status:** Complete

---

## Summary

Implemented composite provider selection policy for `@tjr-suite/market-data-core`, enabling deterministic, reproducible provider selection based on capabilities, freshness requirements, and priority. The implementation supports automatic provider selection, freshness TTL enforcement, priority override, and comprehensive logging of selection rationale.

---

## Deliverables

### ADR

- **docs/adr/ADR-0203-composite-policy.md**
  - Documented capabilities-based selection algorithm
  - Defined freshness TTL enforcement mechanism
  - Specified priority override behavior
  - Outlined comprehensive logging requirements
  - Evaluated alternatives (runtime discovery, weighted scoring, external config)
  - Established acceptance criteria for deterministic, transparent provider selection

### Implementation

- **packages/market-data-core/src/composite.ts** - Core implementation with:
  - `ProviderCapabilities` interface defining provider metadata structure
  - `SelectProviderOptions` interface for selection criteria
  - `ProviderSelectionResult` interface for selection outcomes
  - `selectProvider()` function implementing 4-step deterministic algorithm:
    1. Filter by capability (timeframe, asset class, lookback)
    2. Filter by freshness constraint (if specified)
    3. Apply preference override (if specified and capable)
    4. Select provider with lowest priority value
  - `loadCapabilities()` helper for loading provider metadata
  - Comprehensive JSDoc documentation with examples

- **packages/market-data-core/src/index.ts** - Updated to export:
  - `selectProvider()` and `loadCapabilities()` functions
  - `ProviderCapabilities`, `SelectProviderOptions`, `ProviderSelectionResult` types

### Configuration

- **packages/market-data-core/capabilities.json** - Provider metadata for 5 providers:
  - **yahoo**: Delayed data (15min), limited history (7d), stocks/ETF/index, priority 20
  - **polygon**: Real-time, extensive history (730d), multi-asset, priority 10
  - **alpaca**: Real-time, good history (365d), stocks/crypto, priority 15
  - **coinbase**: Real-time, moderate history (180d), crypto only, priority 12
  - **binance**: Real-time, extensive history (365d), crypto only, priority 8 (highest)

### Documentation

- **ADR-0203** establishes architectural foundation for multi-provider data fetching
- **Journal fragment** (this document) captures implementation details and validation

---

## Technical Highlights

### Deterministic Selection Algorithm

The `selectProvider()` function guarantees reproducible behavior:

- **No randomness** - Selection is purely deterministic based on inputs
- **No external state** - No network calls, file reads, or environment variables
- **Pure function** - Same inputs always produce same output
- **Testable** - Easy to write snapshot tests for provider matrix

### Comprehensive Logging

Every selection result includes:

- `providerId`: Selected provider (or `null` if none capable)
- `reason`: Human-readable explanation of selection rationale
- `excluded`: Array of excluded providers with specific exclusion reasons

Example:
```typescript
{
  providerId: "polygon",
  reason: "Selected polygon: supports 5m timeframe, stocks asset class, 30d lookback, freshness 0s <= 60s max, priority 10",
  excluded: [
    { providerId: "yahoo", reason: "freshness 900s exceeds max staleness 60s" },
    { providerId: "alpaca", reason: "max lookback 365d < required 730d" }
  ]
}
```

### Freshness TTL Enforcement

The `maxStalenessSec` parameter enables use-case-specific freshness requirements:

- **Real-time trading**: `maxStalenessSec: 5` (exclude delayed providers)
- **Backtesting**: `maxStalenessSec: undefined` (freshness irrelevant)
- **Intraday analysis**: `maxStalenessSec: 900` (15min delay acceptable)

Providers with `freshnessSeconds > maxStalenessSec` are automatically excluded.

### Priority Override Mechanism

The `preferProviderId` parameter supports edge cases:

- **Testing**: Force specific provider for reproducible tests
- **Cost control**: Prefer free providers when experimenting
- **Compliance**: Force specific provider for regulatory requirements

If preferred provider is not capable, algorithm falls back to priority selection and logs why preference was ignored.

---

## Test Results

**Tests not yet implemented** - To be added in next commit. Test plan:

### Test Matrix (Planned)

1. **Capability filtering**:
   - Provider supports required timeframe
   - Provider does not support required timeframe
   - Provider supports required asset class
   - Provider does not support required asset class
   - Provider has sufficient lookback period
   - Provider has insufficient lookback period

2. **Freshness filtering**:
   - Provider meets freshness constraint
   - Provider exceeds freshness constraint
   - No freshness constraint specified

3. **Priority override**:
   - Preferred provider is capable → selected
   - Preferred provider not capable → fallback to priority
   - No preference specified → priority selection

4. **Priority selection**:
   - Single capable provider → selected
   - Multiple capable providers → lowest priority wins
   - No capable providers → returns null

5. **Edge cases**:
   - Empty provider list
   - All providers excluded by capability
   - All providers excluded by freshness

---

## Known Limitations

1. **Static capabilities** - Provider metadata must be manually updated in JSON
2. **No runtime discovery** - Cannot auto-detect new providers or capability changes
3. **Simple priority model** - No support for complex cost/latency tradeoffs
4. **No provider adapters** - Selection logic only; actual data fetching in future phases
5. **No caching** - Future phases will add caching layer with TTL-based invalidation

These limitations are acceptable for Phase 2.B4 (provider selection foundation). Future phases will add provider adapters, caching, and advanced selection policies.

---

## Acceptance Criteria

✅ `selectProvider()` function implemented with deterministic algorithm
✅ Capabilities defined in `capabilities.json` for 5+ providers
✅ Freshness TTL enforcement via `maxStalenessSec` parameter
✅ Priority override via `preferProviderId` parameter
✅ Selection result includes `reason` and `excluded` for transparency
⏳ Snapshot tests covering provider selection matrix (next commit)
⏳ Build and tests pass (`pnpm build && pnpm test`)
⏳ Integration with dev-scripts `check:bars` validation (future phase)

---

## Files Changed

### Added

- docs/adr/ADR-0203-composite-policy.md
- packages/market-data-core/src/composite.ts
- packages/market-data-core/capabilities.json
- docs/journal/_fragments/2/2.B4-composite-policy.md

### Modified

- packages/market-data-core/src/index.ts (added composite exports)

---

## Validation Commands

```bash
# Build the package
cd packages/market-data-core
pnpm build

# Run tests (to be added)
pnpm test

# Verify exports
node -e "const { selectProvider } = require('./dist/index.js'); console.log(typeof selectProvider);"
```

---

## Next Steps

1. Implement comprehensive test suite in `tests/composite.test.js`
2. Add JSON schema validation for `capabilities.json`
3. Integrate with provider adapters (Yahoo, Polygon, Binance) in Phase 2.B5-B7
4. Add caching layer with TTL-based invalidation in Phase 2.C1
5. Implement fallback/retry logic for provider failures in Phase 2.C2

---

## Lessons Learned

### What Went Well

- **Pure function approach** - Deterministic selection makes testing and debugging straightforward
- **Comprehensive logging** - Selection rationale and excluded providers provide excellent debugging visibility
- **Flexible configuration** - JSON-based capabilities easy to extend and version
- **Simple priority model** - Adequate for current needs, can be extended later

### What Could Be Improved

- **Test-driven development** - Should have written tests before implementation
- **Schema validation** - Should validate capabilities.json structure to catch misconfigurations early
- **Performance profiling** - Should benchmark selection with 50+ providers to ensure O(n) performance acceptable

### Blockers Encountered

None - Straightforward implementation based on clear requirements in ADR-0203.

---

## References

- Issue: #22 [P2][B4] Composite selection policy
- ADR: ADR-0203-composite-policy.md
- Related ADRs:
  - ADR-0055: Market Data Core (defines Bar, Timeframe types)
  - ADR-0200: Provider Adapter Interface (future)
  - ADR-0201: Caching Strategy (future)