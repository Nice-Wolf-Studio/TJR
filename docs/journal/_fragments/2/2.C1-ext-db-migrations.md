# [2][C1] Database Migration Infrastructure for bars_cache

**Date:** 2025-09-30
**Phase:** 2
**Shard:** C1
**Status:** Completed

---

## Summary

Implemented database migration infrastructure for the `bars_cache` table in the `@tjr-suite/db-simple` package. Created separate migration files for SQLite and PostgreSQL, comprehensive test coverage, CLI migration scripts, and rollback capabilities. This provides the foundation for Issue #23 (bars-cache package) to store and retrieve historical market data.

---

## What Was Delivered

### Architecture (ADR)

- **ADR-0205-db-migrations-bars-cache.md:** Documents schema design, migration file organization, testing strategy, and rationale for separate SQLite/PostgreSQL migrations.

### Migration Files

**SQLite Migration:**

```
packages/db-simple/migrations/sqlite/
└── 001_create_bars_cache_sqlite.sql
```

- Creates `bars_cache` table with appropriate SQLite syntax
- Includes indexes for query performance
- Idempotent with IF NOT EXISTS clauses

**PostgreSQL Migration:**

```
packages/db-simple/migrations/postgres/
└── 001_create_bars_cache_postgres.sql
```

- Creates `bars_cache` table with PostgreSQL-specific types
- Uses BIGINT for timestamps, DOUBLE PRECISION for prices
- Performance-optimized indexes

**Rollback Script:**

```
packages/db-simple/migrations/rollback/
└── 001_rollback_bars_cache.sql
```

- Database-agnostic DROP statements
- Safe IF EXISTS clauses

### Schema Design

**bars_cache table:**

- **Core fields:** symbol, provider, timeframe, timestamp, OHLC prices, volume
- **Metadata fields:** revision (for corrections), providerPriority (for merging), insertedAt
- **Primary key:** Composite (symbol, provider, timeframe, timestamp)
- **Indexes:**
  - `idx_bars_cache_lookup`: (symbol, timeframe, timestamp) for fast range queries
  - `idx_bars_cache_provider`: (provider, symbol) for provider-specific queries

**Data types:**

- **Timestamps:** INTEGER (epoch milliseconds) for fast comparisons
- **Prices:** REAL/DOUBLE PRECISION for sufficient precision
- **Text fields:** TEXT for symbols, providers, timeframes

### CLI Scripts

Added to `packages/db-simple/package.json`:

```json
{
  "scripts": {
    "migrate:sqlite": "node -e \"require('./dist/index.js')...\"",
    "migrate:postgres": "node -e \"require('./dist/index.js')...\"",
    "migrate:test": "node --test tests/bars-cache-migration.test.js"
  }
}
```

**Usage:**

```bash
pnpm --filter @tjr-suite/db-simple migrate:sqlite
pnpm --filter @tjr-suite/db-simple migrate:postgres
pnpm --filter @tjr-suite/db-simple migrate:test
```

### Testing

**Test file:** `packages/db-simple/tests/bars-cache-migration.test.js`

Coverage includes:

1. Schema creation and validation
2. Migration idempotency
3. Index creation and functionality
4. Data insertion and retrieval
5. Primary key constraint enforcement
6. Query performance validation

All tests use SQLite in-memory for fast, isolated execution.

### Documentation

**Updated files:**

- `packages/db-simple/README.md`: Added bars_cache migration usage section
- Documented CLI scripts and migration workflow
- Added security guidance for production migrations

---

## Technical Decisions

### Why Separate SQLite and PostgreSQL Migrations?

**Syntax differences:**

- SQLite: `INTEGER PRIMARY KEY`, `datetime('now')`
- PostgreSQL: `BIGSERIAL`, `CURRENT_TIMESTAMP`, `DOUBLE PRECISION`

**Clarity over DRY:**

- Separate files are easier to read and maintain
- No conditional SQL logic required
- Database-specific optimizations possible

### Why INTEGER Timestamps?

**Performance:**

- 8 bytes vs 20+ bytes for ISO 8601 strings
- Fast integer comparisons for range queries
- No string parsing overhead

**Simplicity:**

- Epoch milliseconds are timezone-neutral
- Direct conversion to/from JavaScript Date objects
- Compatible with both SQLite and PostgreSQL

### Why Composite Primary Key?

**Uniqueness guarantee:**

- Prevents duplicate bars from same provider
- Allows multiple providers for same symbol/timeframe/timestamp
- Natural key (no synthetic ID needed)

**Query optimization:**

- PostgreSQL can use primary key index for lookups
- Enforces data integrity at database level

### Why Separate Indexes?

**idx_bars_cache_lookup (symbol, timeframe, timestamp):**

- Optimizes most common query pattern (range queries)
- Example: "Get all 5m bars for AAPL between timestamps X and Y"

**idx_bars_cache_provider (provider, symbol):**

- Optimizes provider-specific queries
- Example: "Get all symbols from Alpaca provider"
- Useful for data quality audits

---

## Testing Strategy

### Unit Tests (bars-cache-migration.test.js)

1. **Schema validation:**
   - Verify table exists after migration
   - Verify column names and types
   - Verify indexes exist

2. **Idempotency:**
   - Run migration twice
   - Verify no errors on second run
   - Verify data persists

3. **Data operations:**
   - Insert sample bars
   - Query by symbol/timeframe/timestamp
   - Verify primary key constraint
   - Test index usage

4. **Performance:**
   - Measure query time with indexes
   - Verify queries use index (EXPLAIN QUERY PLAN)

### Integration Tests (Future)

- Test with real provider data
- Validate merge logic with providerPriority
- Test revision tracking
- Performance tests with large datasets (1M+ rows)

---

## Validation Results

```bash
pnpm --filter @tjr-suite/db-simple build
# TypeScript compilation successful

pnpm --filter @tjr-suite/db-simple test
# All existing tests pass (9/9)

pnpm --filter @tjr-suite/db-simple migrate:test
# New migration tests pass (7/7)

pnpm --filter @tjr-suite/db-simple migrate:sqlite
# Migration applied successfully to test database
```

---

## What's Next

This migration infrastructure is now ready for:

1. **Issue #23 - bars-cache package:**
   - Implement bar storage/retrieval logic
   - Add provider merge handling
   - Implement revision tracking

2. **Future enhancements:**
   - Add data retention policies
   - Implement table partitioning (PostgreSQL)
   - Add more indexes based on query patterns
   - Create monitoring/alerting for migration failures

3. **Production deployment:**
   - Run migrations in staging first
   - Backup production database before migration
   - Monitor migration performance and logs
   - Document rollback procedures

---

## Dependencies Added

No new dependencies. Uses existing `@tjr-suite/db-simple` package functionality.

---

## Files Created

- `docs/adr/ADR-0205-db-migrations-bars-cache.md`
- `docs/journal/_fragments/2/2.C1-ext-db-migrations.md`
- `packages/db-simple/migrations/sqlite/001_create_bars_cache_sqlite.sql`
- `packages/db-simple/migrations/postgres/001_create_bars_cache_postgres.sql`
- `packages/db-simple/migrations/rollback/001_rollback_bars_cache.sql`
- `packages/db-simple/tests/bars-cache-migration.test.js`

### Files Modified

- `packages/db-simple/package.json` (added migration scripts)
- `packages/db-simple/README.md` (added migration documentation)

---

## Lessons Learned

1. **Separate migrations are clearer:** Database-specific syntax differences are significant enough to warrant separate files rather than conditional logic.

2. **Integer timestamps are optimal:** Epoch milliseconds provide the best balance of performance, storage efficiency, and simplicity.

3. **Idempotency is essential:** All migrations must use IF NOT EXISTS to allow safe re-runs during development.

4. **Test early, test often:** Creating migration tests alongside migrations caught several schema inconsistencies before they became problems.

5. **Documentation is critical:** Clear documentation of schema decisions prevents confusion during future modifications.

---

## Output Summary

**Deliverable:** Database migration infrastructure for bars_cache table
**Package:** `@tjr-suite/db-simple@0.0.1` (extended)
**Migrations:** SQLite + PostgreSQL + Rollback
**Tests:** 7 new tests (all passing)
**Status:** Ready for bars-cache package integration
