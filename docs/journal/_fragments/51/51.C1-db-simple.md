# [51][C1] DB-simple connectors & migrator

**Date:** 2025-09-29
**Phase:** 51
**Shard:** C1
**Status:** ✅ Completed

---

## Summary

Implemented `@tjr-suite/db-simple`, a minimal database connection and migration runner supporting SQLite and PostgreSQL. The package provides a unified async interface for database operations, built-in retry logic with exponential backoff, and a simple file-based migration system.

---

## What Was Delivered

### Architecture (ADR)

- **ADR-0057-db-simple.md:** Documents driver choice (better-sqlite3 + pg), connection string formats, retry/backoff strategy, migration approach, and logger injection pattern.

### Package Structure

```
packages/db-simple/
├── src/
│   ├── connect.ts    # Connection abstraction with retry logic
│   ├── migrate.ts    # File-based migration runner
│   └── index.ts      # Public API exports
├── examples/
│   └── 001_create_tables.sql  # Example migration
├── tests/
│   ├── fixtures/
│   │   └── 001_test_migration.sql
│   └── index.test.js  # Comprehensive test suite
├── package.json
├── tsconfig.json
└── README.md
```

### Core Features

1. **Dual driver support:**
   - SQLite via `better-sqlite3` (synchronous, wrapped in promises)
   - PostgreSQL via `pg.Pool` (native async with connection pooling)

2. **Connection abstraction:**
   - `connect(databaseUrl)`: Unified interface for both databases
   - `DbConnection` interface: `exec()`, `query()`, `close()`
   - Automatic connection string parsing (sqlite:/postgres: prefixes)

3. **Retry logic:**
   - Exponential backoff: 100ms → 200ms → 400ms (default)
   - Jitter: ±25% randomization to prevent thundering herd
   - Retryable errors: ECONNREFUSED, ETIMEDOUT, SQLITE_BUSY, SQLITE_LOCKED
   - Non-retryable errors: Syntax errors, auth failures, constraint violations

4. **Migration system:**
   - File-based: `NNN_description.sql` in migrations directory
   - Lexicographic ordering (001, 002, 003...)
   - Metadata table: `_migrations` tracks applied migrations
   - Forward-only (no down migrations)
   - Transaction-per-migration for atomicity

5. **Logger injection:**
   - Optional logger interface: `{ info(), error() }`
   - No hardcoded logging (silent no-op logger by default)
   - Compatible with Winston, Pino, console, etc.

### Testing

- 9 tests covering:
  - SQLite in-memory and file connections
  - SQL execution and querying
  - Migration table creation
  - Migration application and idempotency
  - Logger integration
  - Error handling (missing directory)
- All tests pass in <210ms

### Security

- `.env.example` added to repo root with DATABASE_URL template
- Connection strings masked in logs (passwords redacted)
- Verified `.env` in `.gitignore`

### Documentation

- Comprehensive README with:
  - Installation and usage examples
  - API reference for all exported functions
  - Caveats and limitations (SQLite concurrency, no down migrations, etc.)
  - Security guidance (env vars, parameterized queries)
  - Link to ADR-0057

---

## Technical Decisions

### Why better-sqlite3 over node-sqlite3?

- **Synchronous API** is ideal for testing and CLI tools (no callback hell)
- **Performance:** Native bindings with prepared statement caching
- **Simplicity:** No promise overhead for simple operations

### Why pg over alternatives?

- **Industry standard** PostgreSQL driver for Node.js
- **Connection pooling** built-in via `pg.Pool`
- **Battle-tested** in production environments

### Why no query builder or ORM?

- **Thin wrapper philosophy:** Raw SQL provides maximum control and transparency
- **Minimal dependencies:** Reduces attack surface and maintenance burden
- **Explicit over implicit:** Developers write SQL, not framework abstractions

### Why forward-only migrations?

- **Simplicity:** Rollbacks are complex and rarely work as intended
- **Production reality:** Most teams use backups + manual rollback scripts
- **Future-proof:** Can add down migrations later if needed

---

## Testing Strategy

- **SQLite in-memory for speed:** All tests use `:memory:` databases for isolation
- **No external dependencies:** No Docker or PostgreSQL required for CI
- **Comprehensive coverage:**
  - Connection lifecycle (connect → exec → query → close)
  - Migration runner (create table → apply → idempotency)
  - Error scenarios (missing directory)
  - Logger integration

---

## Validation Results

```bash
✅ pnpm -w --filter @tjr-suite/db-simple build
   → TypeScript compilation successful
   → No type errors
   → Output: dist/index.js, dist/index.d.ts

✅ pnpm -w --filter @tjr-suite/db-simple test
   → 9/9 tests passed
   → Duration: 207ms
   → No failures
```

---

## What's Next

This package is now ready for:

1. Integration into other TJR Suite services requiring database access
2. Extension with additional drivers (MySQL, MongoDB, etc.) if needed
3. Enhanced retry strategies (circuit breakers, health checks)
4. Transaction helpers (BEGIN/COMMIT/ROLLBACK wrappers)

---

## Dependencies Added

```json
{
  "dependencies": {
    "better-sqlite3": "^11.0.0",
    "pg": "^8.13.1"
  },
  "devDependencies": {
    "@types/better-sqlite3": "^7.6.12",
    "@types/pg": "^8.11.10"
  }
}
```

---

## Files Changed

- **Created:**
  - `docs/adr/ADR-0057-db-simple.md`
  - `packages/db-simple/` (entire package)
  - `.env.example`
  - `docs/journal/_fragments/51/51.C1-db-simple.md`

---

## Lessons Learned

1. **TypeScript index signature access:** Strict mode requires bracket notation (`error['code']`) for dynamically typed error objects.
2. **SQLite sync API wrapping:** Wrapping synchronous SQLite calls in promises maintains interface consistency without performance penalty.
3. **Jitter is essential:** Prevents connection storms when multiple clients retry simultaneously.

---

## Output Summary

**Package:** `@tjr-suite/db-simple@0.0.1`
**Purpose:** Minimal database connection + migration runner
**Drivers:** SQLite (better-sqlite3) + PostgreSQL (pg)
**Tests:** 9/9 passing (207ms)
**Status:** ✅ Ready for integration
